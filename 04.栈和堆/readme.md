1. 栈Stack
    遵循先入后出(LIFO,last in,first out)的线性数据结构，与之相对的是队列结构(FIFO,first in,first out)
    像是餐桌上的盘子，最后放在上面的，要先拿出来才能拿下面的。
    几个专业术语：
    - 入栈 push
    - 出栈 pop
    - 顶部称为“栈顶”，底部称为“栈底”
    典型应用：
    - 历史浏览记录，每次打开一个新的网页，会对上一个网页入栈，如果回退，实际上就是一次出栈
    - 内存管理：调用一个函数。用于记录上下文，执行完毕以后出栈，继续执行源程序
```python
#和队列一样，在python中没有专门的这样的结构，因此是用list来代替

stack = []


# 元素入栈
stack.append(1)
stack.append(3)
stack.append(2)
stack.append(5)
stack.append(4)

# 访问栈顶元素
peek = stack[-1]

# 元素出栈
pop = stack.pop()

# 获取栈的长度
size = len(stack)

# 判断是否为空
is_empty= len(stack) == 0

```

2. 堆 https://www.hello-algo.com/chapter_heap/heap/
   heap堆是一种满足特定条件的完全二叉树，完全二叉树是最底层叶子全部靠左，其余层全部满填充的二叉树。
   堆分成两种：
   - 小顶堆（min heap）：任意节点的值 <=其子节点的值,所以root是最小的
   - 大顶堆（max heap）：任意节点的值 >=其子节点的值，所以root是最大的
  
  在实际的使用中，一般等于优先队列(priority queue)的概念，定义是一种具有优先级排序的队列。比如max heap就是当于元素按从大到小的顺序出队的优先队列（先序遍历顺序）

  堆的实现：因为堆是完全二叉树，所以如果以数组形式存储（层次遍历），不存在None值，能有精确的给定索引i，其左子节点为2i+1，右子节点2i+2，父节点为（i-1）/2
  tips：堆依赖“索引映射公式”来快速找到父节点和子节点，而这个公式只有在层序遍历存储时才成立

  堆的插入（堆化）：因为堆具有严格的递增或者递减关系，所以元素入堆，先放在最后，然后对比它的父节点的大小关系，依次交换位置实现序列修复

  堆顶的pop：根节点是堆顶，如果直接删除，那么所有的索引都会变化，操作如下：
    - 交换堆顶元素与堆底元素（交换根节点与最右叶节点）。
    - 删除原始的堆顶，现在的堆底
    - 从根节点开始，从顶至底执行堆化。
  
  常见应用：
  1. 想实现优先队列，堆是首选数据结构，入队出队的操作都为O（logn）
  2. 堆排序：一堆乱序的列表元素，怎么建一个堆？
  3. 获取K个最大的元素，因为堆结构的栈顶的k个元素就是天然的最大元素，比如微博热搜，销量榜
    - 遍历，时间复杂度高
    - 排序后取k，O（nlogn）
    - 堆操作
   