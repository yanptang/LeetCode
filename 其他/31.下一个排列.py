# 31.下一个排列
# 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
# 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
from typing import List
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #字典序表示，从左到右，逐个比较，第一个不相同的数字拿出来比较，谁的数字小，谁的字典序就小
        #字典序只关心“第一个不一样的位置”
        
        #如果前面都一样，表示在字典序上更为接近，比如 [1,2,3]->[1,3,2]->[2,1,3]
        #所以尽量从右边找，更容易找到下一个字典序排列

        n = len(nums)

        #第一步找第一个非递减的节点
        #[1, 2, 7, 4, 3, 1],我们要找到2的位置，因为后面的不管怎么改也不会大于7
        i=n-2
        while i>=0 and nums[i]>=nums[i+1]:
            i-=1
        
        #step2:找到右边数组里刚好比它大的数，交换位置
        #完成后变化成：[1, 3, 7, 4, 2, 1]
        j = n - 1
        if i >= 0:
            while nums[j]<=nums[i]: #因为右边是递减组，所以直接从右往左找到第一个比节点大的
                j-=1
            nums[i],nums[j]=nums[j],nums[i]
        
        #step3：反转右侧数组，因为我要得到最小的后缀
        #[1,3,1,2,4,7]这个数组明显就更加靠近原数组[1, 2, 7, 4, 3, 1]
        nums[i + 1:] = reversed(nums[i + 1:])